{"remainingRequest":"/Users/lucasdossantos/Desktop/oigr-ui/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/lucasdossantos/Desktop/oigr-ui/node_modules/@progress/kendo-angular-dropdowns/dist/es/autocomplete.component.js","dependencies":[{"path":"/Users/lucasdossantos/Desktop/oigr-ui/node_modules/@progress/kendo-angular-dropdowns/dist/es/autocomplete.component.js","mtime":499162500000},{"path":"/Users/lucasdossantos/Desktop/oigr-ui/node_modules/cache-loader/dist/cjs.js","mtime":1551382622854},{"path":"/Users/lucasdossantos/Desktop/oigr-ui/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["/* tslint:disable:no-null-keyword */\n/* tslint:disable:max-line-length */\n/* tslint:disable:no-bitwise */\nimport { Component, Renderer2, forwardRef, ElementRef, Input, Output, EventEmitter, ContentChild, ViewChild, ViewContainerRef, HostBinding, isDevMode, ChangeDetectorRef, NgZone } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { SearchBarComponent } from './searchbar.component';\nimport { ItemTemplateDirective } from './templates/item-template.directive';\nimport { HeaderTemplateDirective } from './templates/header-template.directive';\nimport { FooterTemplateDirective } from './templates/footer-template.directive';\nimport { SelectionService } from './selection.service';\nimport { NavigationService } from './navigation.service';\nimport { DisabledItemsService } from './disabled-items.service';\nimport { Subject } from 'rxjs/Subject';\nimport { merge } from 'rxjs/observable/merge';\nimport { filter } from 'rxjs/operators/filter';\nimport { isPresent, guid, isDocumentAvailable, getter } from './util';\nimport { NavigationAction } from './navigation-action';\nimport { NoDataTemplateDirective } from './templates/no-data-template.directive';\nimport { Keys } from './common/keys';\nimport { PreventableEvent } from './common/preventable-event';\nimport { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';\nimport { PopupService } from '@progress/kendo-angular-popup';\nvar NO_VALUE = \"\";\n/**\n * @hidden\n */\nexport var AUTOCOMPLETE_VALUE_ACCESSOR = {\n    multi: true,\n    provide: NG_VALUE_ACCESSOR,\n    // tslint:disable-next-line:no-use-before-declare\n    useExisting: forwardRef(function () { return AutoCompleteComponent; })\n};\n/**\n * Represents the Kendo UI AutoComplete component for Angular.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-autocomplete\n *      [data]=\"listItems\"\n *      [placeholder]=\"placeholder\"\n *  >\n * `\n * })\n * class AppComponent {\n *   public placeholder: string = 'Type \"it\" for suggestions';\n *   public listItems: Array<string> = [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"];\n * }\n * ```\n */\nvar AutoCompleteComponent = /*@__PURE__*/ (function () {\n    function AutoCompleteComponent(localization, popupService, selectionService, navigationService, _zone, cdr, renderer, wrapper) {\n        this.localization = localization;\n        this.popupService = popupService;\n        this.selectionService = selectionService;\n        this.navigationService = navigationService;\n        this._zone = _zone;\n        this.cdr = cdr;\n        this.renderer = renderer;\n        /**\n         * @hidden\n         */\n        this.focusableId = \"k-\" + guid();\n        /**\n         * The hint which is displayed when the component is empty.\n         */\n        this.placeholder = \"\";\n        /**\n         * Sets the height of the suggestions list. By default, `listHeight` is 200px.\n         *\n         * > The `listHeight` property affects only the list of suggestions and not the whole popup container.\n         * > To set the height of the popup container, use `popupSettings.height`.\n         */\n        this.listHeight = 200;\n        /**\n         * @hidden\n         *\n         * If set to `true`, renders a button on hovering over the component. Clicking this button resets the value of the component to `undefined` and triggers the `change` event.\n         */\n        this.clearButton = true;\n        /**\n         * Sets the disabled state of the component.\n         */\n        this.disabled = false;\n        /**\n         * Sets the read-only state of the component.\n         */\n        this.readonly = false;\n        /**\n         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabindex = 0;\n        /**\n         * Enables the filter functionality. If set to `true`, the component emits the `filterChange` event.\n         */\n        this.filterable = false;\n        /**\n         * Fires each time the value is changed&mdash;\n         * when the component is blurred or the value is cleared through the **Clear** button.\n         * For more details, refer to the example on [events]({% slug overview_autocomplete %}#toc-events).\n         * When the value of the component is programmatically changed to `ngModel` or `formControl`\n         * through its API or form binding, the `valueChange` event is not triggered because it\n         * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.\n         */\n        this.valueChange = new EventEmitter();\n        /**\n         * Fires each time the user types in the input field.\n         * You can filter the source based on the passed filtration value.\n         * For more details, refer to the example on [events]({% slug overview_autocomplete %}#toc-events).\n         */\n        this.filterChange = new EventEmitter();\n        /**\n         * Fires each time the popup is about to open.\n         * This event is preventable. If you cancel it, the popup will remain closed.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close.\n         * This event is preventable. If you cancel it, the popup will remain open.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires each time the user focuses the AutoComplete.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the AutoComplete gets blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        this.listBoxId = guid();\n        this.optionPrefix = guid();\n        this.onChangeCallback = function (_value) { };\n        this.onTouchedCallback = function (_) { };\n        this.popupMouseDownHandler = function (event) { return event.preventDefault(); };\n        this._popupSettings = { animate: true };\n        this._open = false;\n        this._value = \"\";\n        this._previousValue = NO_VALUE;\n        this._filtering = false;\n        this.valueChangeSubject = new Subject();\n        this._isFocused = false;\n        this.direction = localization.rtl ? 'rtl' : 'ltr';\n        this.wrapper = wrapper.nativeElement;\n        this.data = [];\n        this.subscribeEvents();\n        this.selectionService.resetSelection([-1]);\n    }\n    Object.defineProperty(AutoCompleteComponent.prototype, \"width\", {\n        get: function () {\n            var wrapperOffsetWidth = 0;\n            if (isDocumentAvailable()) {\n                wrapperOffsetWidth = this.wrapper.offsetWidth;\n            }\n            var width = this.popupSettings.width || wrapperOffsetWidth;\n            var minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : wrapperOffsetWidth + \"px\";\n            var maxWidth = isNaN(width) ? width : width + \"px\";\n            return { min: minWidth, max: maxWidth };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"height\", {\n        get: function () {\n            var popupHeight = this.popupSettings.height;\n            return isPresent(popupHeight) ? popupHeight + \"px\" : 'auto';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"listContainerClasses\", {\n        get: function () {\n            var containerClasses = ['k-list-container', 'k-reset'];\n            if (this.popupSettings.popupClass) {\n                containerClasses.push(this.popupSettings.popupClass);\n            }\n            return containerClasses;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"suggestion\", {\n        get: function () {\n            if (!this.text || !this.suggestedText) {\n                this.suggestedText = undefined;\n                return;\n            }\n            var hasMatch = this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase());\n            var shouldSuggest = this.suggest && !this.backspacePressed;\n            if (shouldSuggest && hasMatch) {\n                return this.suggestedText;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"appendTo\", {\n        get: function () {\n            var appendTo = this.popupSettings.appendTo;\n            if (!appendTo || appendTo === 'root') {\n                return undefined;\n            }\n            return appendTo === 'component' ? this.container : appendTo;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Toggles the visibility of the popup. If you use the `toggle` method to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    AutoCompleteComponent.prototype.toggle = function (open) {\n        var _this = this;\n        Promise.resolve(null).then(function () {\n            _this._toggle(open);\n        });\n    };\n    Object.defineProperty(AutoCompleteComponent.prototype, \"isOpen\", {\n        /**\n         * Returns the current open state of the popup.\n         */\n        get: function () {\n            return this._open;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @hidden\n     */\n    AutoCompleteComponent.prototype.togglePopup = function (open) {\n        var isDisabled = this.disabled || this.readonly;\n        var sameState = this.isOpen === open;\n        if (isDisabled || sameState) {\n            return;\n        }\n        var isDefaultPrevented = this.triggerPopupEvents(open);\n        if (!isDefaultPrevented) {\n            this._toggle(open);\n        }\n    };\n    Object.defineProperty(AutoCompleteComponent.prototype, \"activeDescendant\", {\n        get: function () {\n            var dataItem = this.data[this.selectionService.focused];\n            return this.optionPrefix + \"-\" + getter(dataItem, this.valueField);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"noDataLabel\", {\n        get: function () {\n            if (this.data.length === 0) {\n                return this.noDataText;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"data\", {\n        get: function () {\n            return this._data;\n        },\n        /**\n         * Sets the data of the AutoComplete.\n         *\n         * > The data has to be provided in an array-like list.\n         */\n        set: function (data) {\n            this._data = data || [];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"value\", {\n        get: function () {\n            return this._value || NO_VALUE;\n        },\n        /**\n         * Sets the value of the AutoComplete.\n         */\n        set: function (newValue) {\n            this.verifySettings(newValue);\n            this._value = newValue || NO_VALUE;\n            this.cdr.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"popupSettings\", {\n        get: function () {\n            return this._popupSettings;\n        },\n        /**\n         * Configures the popup of the AutoComplete.\n         *\n         * The available options are:\n         * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n         * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup, so that no item labels are wrapped.\n         * - `height: Number`&mdash;Sets the height of the popup container.\n         * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n         * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n         */\n        set: function (settings) {\n            this._popupSettings = Object.assign({ animate: true }, settings);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"tabIndex\", {\n        get: function () {\n            return this.tabindex;\n        },\n        /**\n         * @hidden\n         */\n        set: function (tabIndex) {\n            this.tabindex = tabIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"widgetClasses\", {\n        get: function () {\n            return true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"isFocused\", {\n        get: function () {\n            return this._isFocused;\n        },\n        set: function (isFocused) {\n            this._isFocused = isFocused;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"isDisabled\", {\n        get: function () {\n            return this.disabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AutoCompleteComponent.prototype, \"dir\", {\n        get: function () {\n            return this.direction;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AutoCompleteComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.renderer.removeAttribute(this.wrapper, \"tabindex\");\n        this.localizationChangeSubscription = this.localization\n            .changes\n            .subscribe(function (_a) {\n            var rtl = _a.rtl;\n            _this.direction = rtl ? 'rtl' : 'ltr';\n            _this.setMessages();\n        });\n        this.setMessages();\n    };\n    AutoCompleteComponent.prototype.ngOnDestroy = function () {\n        this.destroyPopup();\n        this.unsubscribeEvents();\n        clearTimeout(this.messagesTimeout);\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n    };\n    AutoCompleteComponent.prototype.ngOnChanges = function (changes) {\n        var STATE_PROPS = /(data|value|valueField)/g;\n        if (STATE_PROPS.test(Object.keys(changes).join())) {\n            this.setState(this.value);\n        }\n        var shouldSuggest = this.suggest && this.data && this.data.length && this.value;\n        if (shouldSuggest) {\n            this.suggestedText = getter(this.data[0], this.valueField);\n        }\n    };\n    /**\n     * Resets the value of the AutoComplete.\n     * If you use the `reset` method to clear the value of the component,\n     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.\n     */\n    AutoCompleteComponent.prototype.reset = function () {\n        this.setState(NO_VALUE);\n    };\n    /**\n     * @hidden\n     */\n    AutoCompleteComponent.prototype.clearValue = function (event) {\n        event.stopImmediatePropagation();\n        this.focus();\n        this._filtering = true;\n        this.change(NO_VALUE);\n        this._filtering = false;\n        this.selectionService.resetSelection([]);\n    };\n    /**\n     * @hidden\n     */\n    AutoCompleteComponent.prototype.writeValue = function (value) {\n        this.setState(value);\n    };\n    /**\n     * @hidden\n     */\n    AutoCompleteComponent.prototype.registerOnChange = function (fn) {\n        this.onChangeCallback = fn;\n    };\n    /**\n     * @hidden\n     */\n    AutoCompleteComponent.prototype.registerOnTouched = function (fn) {\n        this.onTouchedCallback = fn;\n    };\n    /**\n     * @hidden\n     */\n    AutoCompleteComponent.prototype.setDisabledState = function (isDisabled) {\n        this.disabled = isDisabled;\n    };\n    /**\n     * Focuses the AutoComplete.\n     */\n    AutoCompleteComponent.prototype.focus = function () {\n        if (!this.disabled) {\n            this.searchbar.focus();\n        }\n    };\n    /**\n     * Blurs the AutoComplete.\n     */\n    AutoCompleteComponent.prototype.blur = function () {\n        if (!this.disabled) {\n            this.searchbar.blur();\n        }\n    };\n    /**\n     * @hidden\n     */\n    AutoCompleteComponent.prototype.onResize = function () {\n        if (this._open) {\n            var popupWrapper = this.popupRef.popupElement;\n            var _a = this.width, min = _a.min, max = _a.max;\n            popupWrapper.style.minWidth = min;\n            popupWrapper.style.width = max;\n        }\n    };\n    AutoCompleteComponent.prototype.emitChange = function () {\n        if (this.value === this._previousValue) {\n            return;\n        }\n        this._previousValue = this.value;\n        this.onChangeCallback(this.value);\n        this.valueChange.emit(this.value);\n    };\n    AutoCompleteComponent.prototype.verifySettings = function (newValue) {\n        if (!isDevMode()) {\n            return;\n        }\n        if (isPresent(newValue) && typeof newValue !== \"string\") {\n            throw new Error(\"Expected value of type string. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/autocomplete/#toc-value\");\n        }\n    };\n    AutoCompleteComponent.prototype.search = function (text) {\n        var index = text.length ? this.data.findIndex(this.findIndexPredicate(text)) : -1;\n        this.selectionService.focus(index);\n        if (this.suggest) {\n            this.suggestedText = getter(this.data[index], this.valueField);\n        }\n    };\n    AutoCompleteComponent.prototype.navigate = function (index) {\n        if (!this.isOpen) {\n            return;\n        }\n        if (index < 0 || index > this.data.length) {\n            index = 0;\n        }\n        this.selectionService.focus(index);\n    };\n    /**\n     * @hidden\n     */\n    AutoCompleteComponent.prototype.handleNavigate = function (event) {\n        var focused = isNaN(this.selectionService.focused) ? 0 : this.selectionService.focused;\n        var hasFocused = isPresent(focused);\n        var offset = 0;\n        if (this.disabled || this.readonly) {\n            return;\n        }\n        if (!hasFocused) {\n            if (event.keyCode === Keys.down) {\n                offset = -1;\n            }\n            else if (event.keyCode === Keys.up) {\n                offset = 1;\n            }\n        }\n        var action = this.navigationService.process({\n            current: focused + offset,\n            max: this.data.length - 1,\n            min: 0,\n            originalEvent: event\n        });\n        if (action !== NavigationAction.Undefined &&\n            action !== NavigationAction.Backspace &&\n            action !== NavigationAction.Delete &&\n            action !== NavigationAction.Home &&\n            action !== NavigationAction.End &&\n            action !== NavigationAction.Left &&\n            action !== NavigationAction.Right &&\n            ((action === NavigationAction.Enter && this.isOpen) || action !== NavigationAction.Enter)) {\n            event.preventDefault();\n        }\n    };\n    AutoCompleteComponent.prototype.handleEnter = function (event) {\n        var focused = this.selectionService.focused;\n        var value;\n        this._filtering = false;\n        if (this.isOpen) {\n            event.originalEvent.preventDefault();\n        }\n        if (focused >= 0) {\n            value = getter(this.data[focused], this.valueField);\n        }\n        else {\n            var match = this.suggest && this.suggestedText && this.data.length &&\n                getter(this.data[0], this.valueField, true).toLowerCase() === this.searchbar.value.toLowerCase();\n            if (this.isOpen && match) {\n                value = this.suggestedText;\n            }\n            else {\n                value = this.searchbar.value;\n            }\n        }\n        this.change(value);\n    };\n    /**\n     * @hidden\n     */\n    AutoCompleteComponent.prototype.searchBarChange = function (text) {\n        var currentTextLength = this.text.length;\n        this.backspacePressed = (text.length < currentTextLength) ? true : false;\n        this.text = text;\n        this.togglePopup(text.length > 0);\n        this._filtering = true;\n        if (this.filterable) {\n            this.selectionService.focused = -1;\n            this.filterChange.emit(text);\n        }\n        else {\n            this.search(text);\n        }\n    };\n    /**\n     * @hidden\n     */\n    AutoCompleteComponent.prototype.handleFocus = function () {\n        this.isFocused = true;\n        this.onFocus.emit();\n    };\n    /**\n     * @hidden\n     */\n    AutoCompleteComponent.prototype.handleBlur = function () {\n        this._filtering = false;\n        var focused = this.filterable ? this.selectionService.focused : -1;\n        var dataItem;\n        var text;\n        var value = this.value;\n        if (focused !== -1) {\n            dataItem = this.data[focused];\n            text = getter(dataItem, this.valueField, true) || \"\";\n        }\n        else {\n            text = this.searchbar.value;\n        }\n        if (text === this.searchbar.value) {\n            value = text;\n        }\n        else if (text && text.toLowerCase() === this.searchbar.value.toLowerCase()) {\n            this.selectionService.resetSelection([]);\n            value = this.searchbar.value;\n        }\n        this.change(value);\n        this.togglePopup(false);\n        this.isFocused = false;\n        this.onBlur.emit();\n        this.onTouchedCallback();\n    };\n    AutoCompleteComponent.prototype.setState = function (newValue) {\n        if (this._filtering) {\n            return;\n        }\n        this.value = newValue;\n        this._previousValue = this.value;\n        this.text = this.value;\n    };\n    AutoCompleteComponent.prototype.change = function (value) {\n        this.togglePopup(false);\n        this.valueChangeSubject.next(value);\n    };\n    AutoCompleteComponent.prototype.subscribeEvents = function () {\n        var _this = this;\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.valueChangeSubscription = this.valueChangeSubject.pipe(filter(function (candidate) {\n            return !(_this.value === candidate && _this.text === candidate);\n        }))\n            .subscribe(function (value) {\n            _this.value = value;\n            _this.text = value;\n            if (_this.filterable && !_this.value && !_this.text) {\n                _this.filterChange.emit(\"\");\n            }\n            _this.emitChange();\n        });\n        this.changeSubscription = this.selectionService.onChange.subscribe(this.handleItemChange.bind(this));\n        this.focusSubscription = this.selectionService.onFocus.subscribe(this.handleItemFocus.bind(this));\n        this.navigationSubscription = merge(this.navigationService.up, this.navigationService.down).subscribe(function (event) { return _this.navigate(event.index); });\n        this.closeSubscription = this.navigationService.close.subscribe(function () { return _this.togglePopup(false); });\n        this.enterSubscription = this.navigationService.enter.subscribe(this.handleEnter.bind(this));\n        this.escSubscription = this.navigationService.esc.subscribe(this.handleBlur.bind(this));\n    };\n    AutoCompleteComponent.prototype.unsubscribeEvents = function () {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.changeSubscription.unsubscribe();\n        this.navigationSubscription.unsubscribe();\n        this.closeSubscription.unsubscribe();\n        this.enterSubscription.unsubscribe();\n        this.escSubscription.unsubscribe();\n        this.valueChangeSubscription.unsubscribe();\n        this.focusSubscription.unsubscribe();\n    };\n    AutoCompleteComponent.prototype.handleItemChange = function (event) {\n        var index = event.indices.length ? event.indices[0] : undefined;\n        this._filtering = false;\n        this.selectionService.resetSelection([-1]);\n        if (!isPresent(index)) {\n            return;\n        }\n        var text = getter(this.data[index], this.valueField);\n        this.change(text);\n    };\n    AutoCompleteComponent.prototype.handleItemFocus = function (_event) {\n        var focused = this.selectionService.focused;\n        var shouldSuggest = Boolean(this.suggest && this.data && this.data.length && focused >= 0);\n        if (shouldSuggest) {\n            this.suggestedText = getter(this.data[focused], this.valueField);\n        }\n    };\n    AutoCompleteComponent.prototype.createPopup = function () {\n        var _this = this;\n        this.popupRef = this.popupService.open({\n            anchor: this.wrapper,\n            animate: this.popupSettings.animate,\n            appendTo: this.appendTo,\n            content: this.popupTemplate,\n            popupClass: this.listContainerClasses,\n            positionMode: 'absolute'\n        });\n        var popupWrapper = this.popupRef.popupElement;\n        var _a = this.width, min = _a.min, max = _a.max;\n        popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);\n        popupWrapper.style.minWidth = min;\n        popupWrapper.style.width = max;\n        popupWrapper.style.height = this.height;\n        popupWrapper.setAttribute(\"dir\", this.direction);\n        this.popupRef.popupAnchorViewportLeave.subscribe(function () { return _this.togglePopup(false); });\n    };\n    AutoCompleteComponent.prototype.destroyPopup = function () {\n        if (this.popupRef) {\n            this.popupRef.popupElement\n                .removeEventListener('mousedown', this.popupMouseDownHandler);\n            this.popupRef.close();\n            this.popupRef = null;\n        }\n    };\n    AutoCompleteComponent.prototype._toggle = function (open) {\n        this._open = (open === undefined) ? !this._open : open;\n        this.destroyPopup();\n        if (this._open) {\n            this.createPopup();\n        }\n    };\n    AutoCompleteComponent.prototype.triggerPopupEvents = function (open) {\n        var eventArgs = new PreventableEvent();\n        if (open) {\n            this.open.emit(eventArgs);\n        }\n        else {\n            this.close.emit(eventArgs);\n        }\n        return eventArgs.isDefaultPrevented();\n    };\n    AutoCompleteComponent.prototype.findIndexPredicate = function (text) {\n        var _this = this;\n        return function (item) {\n            var itemText = getter(item, _this.valueField);\n            itemText = itemText === undefined ? \"\" : itemText.toString().toLowerCase();\n            return itemText.startsWith(text.toLowerCase());\n        };\n    };\n    AutoCompleteComponent.prototype.setMessages = function () {\n        var _this = this;\n        this._zone.runOutsideAngular(function () {\n            clearTimeout(_this.messagesTimeout);\n            _this.messagesTimeout = setTimeout(function () {\n                _this.noDataText = _this.localization.get('noDataText');\n                _this.cdr.detectChanges();\n            });\n        });\n    };\n    return AutoCompleteComponent;\n}());\nexport { AutoCompleteComponent };\n",null]}